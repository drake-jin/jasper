<xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title></title>
   
   <link>blog.drakejin.me</link>
   <description>데이터 분석은 잘 못하지만, 데이터 분석할 수 있게 도와드리겠어요!</description>
   <language>utf-8</language>
   <managingEditor> drakejin</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>(스터디) 도커.araboza - 5</title>
	  <link>//%EC%8A%A4%ED%84%B0%EB%94%94-%EB%8F%84%EC%BB%A4-5</link>
	  <author>drakejin</author>
	  <pubDate>2017-04-18T00:00:00+09:00</pubDate>
	  <guid>//%EC%8A%A4%ED%84%B0%EB%94%94-%EB%8F%84%EC%BB%A4-5</guid>
	  <description><![CDATA[
	     <p>[데이터 공작소] 데이터 공작소는 도커는 어떻게 공부할것인가! 처음 시작하는 도커에 대해 공부를 시작합니다. 이 문서의 저작권은 <img src="http://pyrasis.com/private/2014/11/30/publish-docker-for-the-really-impatient-book" alt="pyrasis.com" /> 여기에 있습니다. 혼자 공부하려고 글들의 내용을 참고하였습니다. 문제시 삭제하겠습니다.</p>

<h2 id="docker-history">docker history</h2>
<p>이미지 히스토리를 살펴보도록 하자.</p>

<p><code class="highlighter-rouge">bash
$ sudo docker history {image_name}:{tag}
# or
$ sudo docker history {image_id}
</code>
아이디 값{image_id} 또는 {image_name}:{tag}을 이용하여 설치한 이미지의 내역을 확인할 수 있다.</p>

<h4 id="section">실행 화면</h4>

<p><img src="./images/history.png" alt="docker history" /></p>

<h2 id="docker-cp">docker cp</h2>
<p>컨테이너 내부의 파일을 꺼내와보자.</p>

<h4 id="section-1">실행 화면</h4>

<p><img src="./images/cp.png" alt="docker cp" /></p>

<p><code class="highlighter-rouge">bash 
$ sudo docker cp {container_name}:{container_internal_file} {store_path}
</code></p>

<h1 id="docker-commit">docker commit</h1>
<p>컨테이너의 변경사항을 이미지로 저장</p>

<p><code class="highlighter-rouge">bash
$ sudo docker commit -{option} "{title}" -m "{content}" {container_name} {image_name}:{tag}
</code></p>

<h4 id="section-2">실행 화면</h4>

<p><img src="./images/commit.png" alt="docker commit" /></p>

<h2 id="docker-diff">docker diff</h2>
<p>commit 이후 컨테이너에서 변경된 파일 확인하기</p>

<ul>
  <li>A는 추가된 파일</li>
  <li>C는 변경된 파일</li>
  <li>D는 삭제된 파일</li>
</ul>

<p><code class="highlighter-rouge">bash
$ sudo docker diff {container_name}
</code></p>

<h4 id="section-3">실행화면</h4>

<p><img src="./images/diff.png" alt="docker diff" /></p>

<h1 id="docker-inspect">docker inspect</h1>
<p>컨테이너 세부정보 확인</p>

<p><code class="highlighter-rouge">bash
$ sudo docker inspect {container_name}
</code></p>

<h4 id="section-4">실행화면</h4>

<p><img src="./images/inspect.png" alt="docker inspect" /></p>

	  ]]></description>
	</item>

	<item>
	  <title>(스터디) 도커.araboza - 4</title>
	  <link>//%EC%8A%A4%ED%84%B0%EB%94%94-%EB%8F%84%EC%BB%A4-4</link>
	  <author>drakejin</author>
	  <pubDate>2017-04-12T00:00:00+09:00</pubDate>
	  <guid>//%EC%8A%A4%ED%84%B0%EB%94%94-%EB%8F%84%EC%BB%A4-4</guid>
	  <description><![CDATA[
	     <p>[데이터 공작소] 데이터 공작소는 도커는 어떻게 공부할것인가! 처음 시작하는 도커에 대해 공부를 시작합니다. 이 문서의 저작권은 <img src="http://pyrasis.com/private/2014/11/30/publish-docker-for-the-really-impatient-book" alt="pyrasis.com" /> 여기에 있습니다. 혼자 공부하려고 글들의 내용을 참고하였습니다. 문제시 삭제하겠습니다.</p>

<h2 id="docker-image-">Docker Image 만들기</h2>

<h3 id="bash--">bash 기본 명령</h3>

<p><img src="http://pyrasis.com/book/DockerForTheReallyImpatient/Chapter04" alt="pyraris에 있는 bash기본 명령어를 따라해봅시당" /></p>

<p>기분좋게 한번 따라해봅시당</p>

<h3 id="dockerfile-">DockerFile 작성하기</h3>

<p><img src="http://pyrasis.com/book/DockerForTheReallyImpatient/Chapter04/02" alt="pyraris를 보고 dockerFile을 작성해봅시당" /></p>

<h3 id="build----">build 명령으로 이미지를 생성해 봅시다.</h3>

<p>docker image를 만들때에는 DockerFile 을 이용해야 합니다.</p>

<p><code class="highlighter-rouge">
 $ sudo docker build --tag {image_name}:{tag} {dockerfile_path}
</code>
 - {dockerfile_path} 이 존재하는 경로를 입력해야함.
 -  이미지 이름만 설정하면 태그는 latest로 설정됨.</p>

<h4 id="section">실행 화면</h4>

<p><img src="images/sudo_docker_build.png" alt="sudo docker build" /></p>

<h2 id="run--container-">생성된 이미지를 run 하여 container를 생성해봅시다.</h2>

<p><code class="highlighter-rouge">bash
 $ sudo docker run --name {container_name} -d -p {host_port}:{container_port} -v {host_dir}:{container_dir} 
</code></p>

<ul>
  <li>-d =&gt; 컨테이너를 백그라운드로 실행한다.</li>
  <li>-p {host_port}:{container_port} =&gt; 컨테이너의 포트와 호스트의 포트를 연결하여 외부에 노출.</li>
  <li>-v {host_dir}:{container_dir} =&gt; 컨테이너의 디렉토리와 호스트의 디렉토리를 연결하여 호스트에서 컨테이너의 디렉토리를 읽습니다.</li>
</ul>

<h4 id="section-1">실행 화면</h4>

<p><img src="images/sudo_docker_run.png" alt="sudo docker run" /></p>

<p><img src="images/nginx.png" alt="sudo_docker_access" /></p>


	  ]]></description>
	</item>

	<item>
	  <title>(스터디) 도커.araboza - 3</title>
	  <link>//%EC%8A%A4%ED%84%B0%EB%94%94-%EB%8F%84%EC%BB%A4-3</link>
	  <author>drakejin</author>
	  <pubDate>2017-04-08T00:00:00+09:00</pubDate>
	  <guid>//%EC%8A%A4%ED%84%B0%EB%94%94-%EB%8F%84%EC%BB%A4-3</guid>
	  <description><![CDATA[
	     <p>[데이터 공작소] 데이터 공작소는 도커는 어떻게 공부할것인가! 처음 시작하는 도커에 대해 공부를 시작합니다. 이 문서의 저작권은 <img src="http://pyrasis.com/private/2014/11/30/publish-docker-for-the-really-impatient-book" alt="pyrasis.com" /> 여기에 있습니다. 혼자 공부하려고 글들의 내용을 참고하였습니다. 문제시 삭제하겠습니다.</p>

<h2 id="section">도커 기본 명령어</h2>

<p>docker 명령어는 sudo 명령어와 함께하거나 root사용자로 이용해야 합니다.</p>

<h3 id="search">search</h3>
<p>search명령어로 docker hub에 올라와있는 이미지를 검색하기 <img src="https://registry.hub.docker.com" alt="docker hub" />에 유명 이미지들은 {user}/{image}이런 형식이 아니라 {image}명만 있습니다.</p>

<p><code class="highlighter-rouge">bash
 $ sudo docker search {image_name}
</code></p>

<h6 id="section-1">실행 화면</h6>
<p><img src="images/sudo_docker_search.png" alt="sudo docker search" /></p>

<h3 id="pull">pull</h3>
<p>pull 명령어는 dockerhub에 있는 이미지를 다운받는데 사용합니다.</p>

<p><code class="highlighter-rouge">bash
 $ sudo docker pull {image_name}:{tag}
</code>
tag자리에 latest를 입력하면 이미지의 최신버전을 다운받습니다. 
- <img src="https://hub.docker.com/r/library/ubuntu/tags/" alt="docker tags" />
위 링크에서 tag 자리에 올 적합한 버전을 찾아서 입력하면 해당 tag 버전으로 설치할 수 있습니다.</p>

<h5 id="section-2">실행 화면</h5>
<p><img src="images/sudo_docker_pull.png" alt="sudo docker pull iamges_name_tag" /></p>

<h3 id="images">images</h3>
<p>다운받은 이미지 목록 출력하기</p>

<p><code class="highlighter-rouge">
 $ sudo docker images 
</code> 
위 명령은 모든 이미지 목록을 출력합니다.</p>

<h5 id="section-3">실행화면</h5>

<p><img src="images/sudo_docker_images.png" alt="sudo docker images" /></p>

<h3 id="run">run</h3>
<p>컨테이너 생성하는 명령어, 다운 받은 이미지를 기반으로 컨테이너를 만듭니다.</p>

<p><code class="highlighter-rouge">bash
$ sudo docker run -i -t --name {container_name} {image_name} {login_shell}
</code>
 - -i : Interactive =&gt; 실행된 셸의 입출력을 사용합니다.
 - -t : Pseudo-tty =&gt; 로그인 셸을 어떤걸 사용할 지 정합니다.
 - –name : 컨테이너의 이름을 지정합니다, 이를 설정하지 않으면 도커에서 임의로 설정하게 됩니다.</p>

<p>이 과정을 통해 호스트 OS와 완전히 격리된 공간이 생기게 되었습니다.</p>

<blockquote>
  <p>빠져나오기 
- ctrl + p &amp; ctrl + q =&gt; 해당 컨테이너를 종료하지 않고 나옵니다.
- exit : 해당 컨테이너를 종료하고 나옵니다.</p>
</blockquote>

<h5 id="section-4">실행화면</h5>

<p><img src="images/sudo_docker_run.png" alt="sudo docker run -i -t --name" /></p>

<h3 id="ps">ps</h3>
<p>컨테이너의 목록 확인하기</p>

<p><code class="highlighter-rouge">bash
$ sudo docker ps -a 
</code>
-a옵션은 정지된 컨테이너 까지 모두 출력하고, 옵션을 사용하지 않으면 컨테이너만 출력합니다.</p>

<h5 id="section-5">실행화면</h5>

<p><img src="images/sudo_docker_ps.png" alt="sudo docker ps" /></p>

<h3 id="start">start</h3>
<p>정지된 컨테이너를 구동시킬 때 사용한다.</p>

<p><code class="highlighter-rouge">bash
 $ sudo docker start {container_name}
</code></p>

<h5 id="section-6">실행화면</h5>

<p><img src="images/sudo_docker_start.png" alt="sudo docker start" /></p>

<h3 id="stop">stop</h3>
<p>실행된 컨테이너를 정지 시킬 때 사용한다.</p>

<p><code class="highlighter-rouge">bash
 $ sudo docker stop {container_name} 
</code></p>

<h5 id="section-7">실행화면</h5>

<p><img src="images/sudo_docker_stop.png" alt="sudo_docker_stop" /></p>

<h3 id="restart">restart</h3>

<p>실행된 컨테이너를 재구동 하기위해 사용한다.</p>

<p><code class="highlighter-rouge">bash
 $ sudo docker restart {container_name}
</code></p>

<h5 id="section-8">실행화면</h5>

<p><img src="images/sudo_docker_restart.png" alt="sudo docker restart" /></p>

<h3 id="attach">attach</h3>
<p>실행된 컨테이너에 접속하기위해 사용한다.
<code class="highlighter-rouge">bash
 $ sudo docker attach {container_name}
</code></p>

<h5 id="section-9">실행화면</h5>

<p><img src="images/sudo_docker_attach.png" alt="sudo docker attach" /></p>

<h3 id="exec">exec</h3>
<p>실행된 컨테이너에 접속하지않고 명령어를 수행하기 위해 사용한다. 결과창은 Host OS 에서 확인 할 수 있다.</p>

<p><code class="highlighter-rouge">bash
 $ sudo docker exec {container_name} [arg[0], arg[1], arg[2], arg[3]]
</code></p>

<h5 id="section-10">실행화면</h5>

<p><img src="images/sudo_docker_exec.png" alt="sudo docker exec" /></p>

<h3 id="rm">rm</h3>
<p>생성된 컨테이너를 삭제한다. 실행되고 있는 컨테이너는 제거할 수 없다.</p>

<p><code class="highlighter-rouge">bash
 $ sudo docker rm {container_name}
</code></p>

<h5 id="section-11">실행화면</h5>

<p><img src="images/sudo_docker_rm.png" alt="sudo_docker_rm" /></p>

<h3 id="rmi">rmi</h3>
<p>설치한 이미지를 삭제한다. 단 삭제하려는 이미지로 생성한 컨테이너가 사용중이거나 만들어져있다면 삭제할 수 없다. 
<code class="highlighter-rouge">bash
 $ sudo docker rmi {image_name}:{tag}
</code></p>

<h5 id="section-12">실행화면</h5>

<p><img src="images/sudo_docker_rmi.png" alt="sudo_docker_rmi" /></p>


	  ]]></description>
	</item>

	<item>
	  <title>(스터디) 도커.araboza - 2</title>
	  <link>//%EC%8A%A4%ED%84%B0%EB%94%94-%EB%8F%84%EC%BB%A4-2</link>
	  <author>drakejin</author>
	  <pubDate>2017-04-07T00:00:00+09:00</pubDate>
	  <guid>//%EC%8A%A4%ED%84%B0%EB%94%94-%EB%8F%84%EC%BB%A4-2</guid>
	  <description><![CDATA[
	     <p>[데이터 공작소] 데이터 공작소는 도커는 어떻게 공부할것인가! 처음 시작하는 도커에 대해 공부를 시작합니다. 이 문서의 저작권은 <img src="http://pyrasis.com/private/2014/11/30/publish-docker-for-the-really-impatient-book" alt="pyrasis.com" /> 여기에 있습니다. 혼자 공부하려고 글들의 내용을 참고하였습니다. 문제시 삭제하겠습니다.</p>

<h1 id="section">설치하기</h1>

<p>Docker는 MAC OS, Windows, Linux(Debian, RedHat)양 진영에 제공한다.</p>


	  ]]></description>
	</item>

	<item>
	  <title>(스터디) 도커.araboza - 1</title>
	  <link>//%EC%8A%A4%ED%84%B0%EB%94%94-%EB%8F%84%EC%BB%A4-1</link>
	  <author>drakejin</author>
	  <pubDate>2017-04-04T00:00:00+09:00</pubDate>
	  <guid>//%EC%8A%A4%ED%84%B0%EB%94%94-%EB%8F%84%EC%BB%A4-1</guid>
	  <description><![CDATA[
	     <p>[데이터 공작소] 데이터 공작소는 도커는 어떻게 공부할것인가! 처음 시작하는 도커에 대해 공부를 시작합니다. 이 문서의 저작권은 <img src="http://pyrasis.com/private/2014/11/30/publish-docker-for-the-really-impatient-book" alt="pyrasis.com" /> 여기에 있습니다. 혼자 공부하려고 글들의 내용을 참고하였습니다. 문제시 삭제하겠습니다.</p>

<h1 id="section">컨테이너의 필요성</h1>

<ul>
  <li>클라우드환경에서 서버는 클릭 몇번으로 만들어 내지만 서버의 환경(설치해야하는 각종 DB 등등..) 을 클릭으로 만들어 낼 수 없었다.</li>
  <li>환경은 OS가 무엇이냐에 따라 설치방법이 달라지고.. 새로 구매한 서버에서 운영환경을 만드는것은 고된 작업중 하나..</li>
  <li>셸 스크립트로 만들어내는것에도 한계가 있다. 셸 스크립트로 중앙 관리 기능이나 복잡한 관리 기능 구현은 힘듦.</li>
  <li>관리해야할 서비스 프로그램이 많아지고.. 설정도 복잡해지고…</li>
  <li>그리고 배포 및 관리를 하는대 서버를 통째로 이미지로 만들어서 올리는것이 좀 더 편리해서 서버를 통째로 샀다가 지우는 경우가 생김</li>
  <li>그러므로 이미지 기반 어플리케이션 배포 패러다임이 등장 (Immutable-infrastructure)</li>
</ul>

<h4 id="immutable-infrastructure-httpblognacyotcomarticles2014-04-06-immutable-infrastructure"><img src="http://blog.nacyot.com/articles/2014-04-06-immutable-infrastructure/" alt="Immutable Infrastructure 패러다임" /></h4>
<ul>
  <li>이미지 기반 어플리케이션 배포 패러다임</li>
  <li>한 번 설정하고 변경하지 않는 이미지 기반의 어플리케이션 배포 패러다임을 뜻함.</li>
  <li>다수의 서버를 동적으로 관리하는 클라우드를 기반으로 효과적이고 유연하게 배포할 수 있을까에 시작함</li>
  <li>기존에 서버를 지속적으로 관리 하는것에 벗어나 어떻게 해야 서버를 잘 쓰고 버리는지가 관건인 패러다임.</li>
  <li>Heroku, Travis에서 이 페러다임을 적극 채용하고 있으며 docker와 serf 같은 도구들은 이 패러다임의 적용을 돕는다.</li>
  <li>호스트 OS와 서비스 운영환경(소스코드, 프로그램, 컴파일된 바이너리)를 분리하고, 한 번 설정한 운영 환경은 변경하지 않음</li>
</ul>

<h4 id="immutable-infrastructure-">Immutable-infrastructure 장점</h4>
<ul>
  <li>관리 용이 : 서비스 운영환경을 이미지로 생성했기 때문에 이미지만 관리하면 됨, docker에서 이미지를 중앙관리 할 것임.</li>
  <li>확장성 : 이미지 하나로 서버를 계속 만들어 낼 수 있다. 클라우드 플랫폼의 자동확장 시능과 함께라면 손쉽게 확장할 수 있다.</li>
  <li>테스트 : 개발자의 PC나 테스트 서버에서 이미지를 실행하기만 하면 서비스 운영 환경과 동일한 환경이 구성되기 때문에 테스트가 쉽다.</li>
  <li>가볍다 : OS에 딸려있는 쓰잘때기 없는 기능들을 안써도 된다.</li>
</ul>

<h1 id="docker-">가상머신과 Docker의 컨테이너</h1>

<h4 id="section-1">가상머신</h4>
<ul>
  <li>가상머신은 완전한 컴퓨터라 항상 <em>게스트 OS</em>를 설치해야 한다. 그래서 이미지 안에 OS가 포함되기 때문에 이미지 용량이 커진다.</li>
  <li>게스트 OS는 넘나 무겁다. 전 가상화 방식의 느린 속도를 개선하기 위해 반 가상화를 내 놓았지만, 반 가상화라는것도 도찐개찐 무겁당.</li>
</ul>

<h4 id="docker">Docker</h4>
<ul>
  <li>Docker는 반 가상화보다 경량화된 방식. 게스트 OS를 설치하지 않음. Docker이미지에 서버 운영을 위한 프로그램과 라이브러리를 격리해서 설치할 수 있다.</li>
  <li>하드웨어를 가상화하는 계층(Hyper-V)이 없기 때문에 메모리 접근, 파일시스템, 네트워크 속도가 가상머신에 비해 월등히 빠름</li>
  <li>메인 호스트와 Docker의 컨테이너 사이의 계층과 성능차이는 크게 발생하지 않는다.</li>
</ul>

<h4 id="vs-docker-">가상머신 vs Docker 비교</h4>
<p><img src="http://patg.net/assets/container_vs_vm.jpg" alt="가상머신 vs Docker" /></p>

<h4 id="xen-hyper-v">반가상화(Xen, Hyper-V)</h4>
<p><img src="http://cfile24.uf.tistory.com/image/2514094E52693DA31D9518" alt="반 가상화" /></p>

<h4 id="chroot-jail">chroot와 jail</h4>
<ul>
  <li>chroot라는 명령을 이용한 방식. 파일 시스템에서 루트 디렉터리를 변경하는 명령</li>
  <li>chroot는 jail이라는 환경을 생성하는대 chroot jail안에서는 바깥의 파일과 디렉토리에 접근할 수 없다.</li>
  <li>chroot디렉토리 경로를 격리하기 때문에 서버정보의 유출과 피해를 최소화 하는데 주로 사용함</li>
  <li>chroot는 jail에 들어갈 실행파일과 공유라이브러리를 직접 준비해야하고 설정방법이 조금 복잡함.</li>
  <li>완벽한 가상머신이 아님</li>
  <li>이후 리눅스는 LXC(LinuX Container)라는 시스템 레벨의 가상화를 제공했다.
<img src="https://debcairn.files.wordpress.com/2014/08/chrooted_fig1.gif" alt="chroot에 대해 아라보쟈" /></li>
</ul>

<h4 id="linux-container-compose-of-cgroups-namespaces">리눅스 컨테이너-1 (LinuX Container compose of cgroups&amp; namespaces)</h4>
<ul>
  <li>LXC 는 컴퓨터를 통째로 가상화 하여 OS를 실행하는게 아닌 리눅스 커널레벨에서 제공하는 일종의 격리(isolate)된 가상의 공간.</li>
  <li>이 가상의 공간이 바로 컨테이너이다.</li>
  <li>리눅스 커널의 Control Groups(cgroups)는 CPU, 메모리, 디스크, 네트워크 자원을 할당하여 완전한 형태의 가상공간을 제공하게 됨</li>
  <li>프로세스 트리, 사용자 계졍, 파일 시스템, IPC등을 격리 시킨 호스트와 별개의 공간. 이를 Namespace Isolation(namespaces)라 부름</li>
  <li>LXC는 격리된 공간을 제공할 뿐, 서비스 운영에 필요한 기능이 부족했다.
<img src="https://image.slidesharecdn.com/lxcnextgenvirtualizationforcloud-introcloudexpo-140613044826-phpapp01/95/lxc-next-gen-virtualization-for-cloud-intro-cloudexpo-4-638.jpg?cb=1402634985" alt="LXC에 대해 알아보자" /></li>
</ul>

<h4 id="add-libcontainer">리눅스 컨테이너-2 (Add libcontainer)</h4>
<ul>
  <li>도커 초기에는 LXC를 기반으로 구현했지만 LXC 를 대신하는 libcontainer를 개발하여 사용하고 있다.</li>
  <li>내부적으로는 실행드라이버(exec driver)라 한다. 이게 도커</li>
  <li>libcontainer는 native 표시</li>
  <li>LXC는 lxc로 표시
<img src="https://cdn-images-1.medium.com/max/1200/1*E8KZJNl21-f1Fb93zgwPWA.jpeg" alt="libcontainer" />
<img src="http://www.publickey1.jp/blog/14/docker09.jpg" alt="냠냠 " /></li>
</ul>

<h1 id="section-2">이미지와 컨테이너의 차이</h1>

<h4 id="section-3">이미지</h4>
<ul>
  <li>리눅스 배포판의 유저랜드만 설치된 파일</li>
  <li>보통 리눅스 배포판 이름으로 되어있다.</li>
  <li>Redis나 Nginx등 설치된 베이스 이미지도 있다.</li>
  <li>즉, 필요한 라이브러리, 바이너리, 소스코드가 설치된 뒤 파일 하나로 묶인 것.</li>
  <li>이미지는 베이스 이미지, 애플리케이션(베이스 이미지가 사용된 것)으로 구분할 수 있다.</li>
  <li>실행할 때에는 베이스이미지에서 바뀐 부분(애플리케이션에서 변경된 부분)을 합쳐서 실행함.</li>
  <li>유저랜드 = 실행파일 + 라이브러리</li>
  <li>유저랜드 = 리눅스 부팅에 필요한 최소 실행파일과 라이브러리 조합(고유의 패키징 시스템을 포함)
<img src="https://image.slidesharecdn.com/webinarrealworlddocker2014-12-09v31-141209161210-conversion-gate01/95/realworld-docker-10-things-weve-learned-28-638.jpg?cb=1461786358" alt="updated base image " />
<img src="http://pyrasis.com/assets/images/DockerForTheReallyImpatientChapter01/10.png" alt="흑" />
<img src="https://i.stack.imgur.com/IsRzv.png" alt="Change and Update" />
##### 이미지 의존성
<img src="http://blog.kollus.com/wp-content/uploads/2015/10/docker_images.gif" alt="이미지 의존성" /></li>
</ul>

<h4 id="section-4">컨테이너</h4>
<ul>
  <li>이미지를 실행한 상태.</li>
  <li>이미지로 여러개의 컨테이너를 만들 수 있다.</li>
  <li>운영체제로 보면 이미지는 실행파일, 컨테이너는 프로세스</li>
  <li>즉, Docker는 특정 실행파일 또는 스크립트를 위한 실행 환경</li>
</ul>


	  ]]></description>
	</item>


</channel>
</rss>
